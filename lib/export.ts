import type { AnalysisResponse } from "./types";

/**
 * Generate formatted Markdown from analysis response
 */
export function generateMarkdown(analysis: AnalysisResponse): string {
  const lines: string[] = [];

  // Header
  lines.push("# Resume Analysis Report");
  lines.push("");
  lines.push(`**Overall Score:** ${analysis.overall_score}/100`);
  lines.push(`**Verdict:** ${formatVerdict(analysis.overall_verdict)}`);
  lines.push("");

  // Roast Summary
  lines.push("## The Roast ðŸ”¥");
  lines.push("");
  lines.push(analysis.roast_summary);
  lines.push("");

  // Quick Wins
  if (analysis.quick_wins.length > 0) {
    lines.push("## Quick Wins âš¡");
    lines.push("");
    analysis.quick_wins.forEach((qw) => {
      const priorityEmoji =
        qw.priority === "high" ? "ðŸ”´" : qw.priority === "medium" ? "ðŸŸ¡" : "ðŸŸ¢";
      lines.push(`- ${priorityEmoji} **${qw.priority.toUpperCase()}:** ${qw.text}`);
    });
    lines.push("");
  }

  // ATS Keywords
  if (analysis.ats_analysis.keywords_missing.length > 0) {
    lines.push("## Missing ATS Keywords âš ï¸");
    lines.push("");
    lines.push(`**ATS Score:** ${analysis.ats_analysis.score}/100`);
    lines.push("");
    lines.push("**Keywords to add:**");
    lines.push(analysis.ats_analysis.keywords_missing.map((k) => `\`${k}\``).join(", "));
    lines.push("");
  }

  // Sections
  lines.push("## Section Analysis");
  lines.push("");

  analysis.sections.forEach((section) => {
    const severityEmoji =
      section.severity === "critical"
        ? "ðŸ”´"
        : section.severity === "warning"
          ? "ðŸŸ¡"
          : "ðŸŸ¢";

    lines.push(`### ${section.name} ${severityEmoji}`);
    lines.push("");
    lines.push(`**Score:** ${section.score}/100 (${formatSeverity(section.severity)})`);
    lines.push("");

    // Original
    lines.push("#### Original");
    lines.push("");
    lines.push("```");
    lines.push(section.original);
    lines.push("```");
    lines.push("");

    // Improved
    lines.push("#### Improved âœ¨");
    lines.push("");
    lines.push("```");
    lines.push(section.improved);
    lines.push("```");
    lines.push("");

    // Improvement Notes
    if (section.improvement_notes) {
      lines.push("#### Why These Changes?");
      lines.push("");
      lines.push(section.improvement_notes);
      lines.push("");
    }

    lines.push("---");
    lines.push("");
  });

  // Footer
  lines.push("*Generated by Resume Roaster AI*");

  return lines.join("\n");
}

/**
 * Format verdict for display
 */
function formatVerdict(verdict: string): string {
  switch (verdict) {
    case "brutal_honesty_needed":
      return "Brutal Honesty Needed";
    case "needs_work":
      return "Needs Work";
    case "solid_foundation":
      return "Solid Foundation";
    case "exceptional":
      return "Exceptional";
    default:
      return verdict;
  }
}

/**
 * Format severity for display
 */
function formatSeverity(severity: string): string {
  switch (severity) {
    case "critical":
      return "Critical";
    case "warning":
      return "Needs Improvement";
    case "good":
      return "Good";
    default:
      return severity;
  }
}

/**
 * Download markdown as file
 */
export function downloadMarkdown(analysis: AnalysisResponse, filename?: string): void {
  const markdown = generateMarkdown(analysis);
  const blob = new Blob([markdown], { type: "text/markdown;charset=utf-8" });
  const url = URL.createObjectURL(blob);

  const link = document.createElement("a");
  link.href = url;
  link.download = filename || `resume-analysis-${Date.now()}.md`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);

  URL.revokeObjectURL(url);
}

/**
 * Compress and encode analysis for URL sharing
 * Uses base64 encoding with optional truncation for very long analyses
 */
export function encodeAnalysisForUrl(analysis: AnalysisResponse): string {
  // Create a minimal version for sharing
  const minimalAnalysis = {
    overall_score: analysis.overall_score,
    overall_verdict: analysis.overall_verdict,
    roast_summary: truncateText(analysis.roast_summary, 500),
    sections: analysis.sections.map((s) => ({
      name: s.name,
      score: s.score,
      severity: s.severity,
      original: truncateText(s.original, 300),
      improved: truncateText(s.improved, 300),
      improvement_notes: truncateText(s.improvement_notes, 200),
    })),
    ats_analysis: {
      keywords_found: analysis.ats_analysis.keywords_found.slice(0, 10),
      keywords_missing: analysis.ats_analysis.keywords_missing.slice(0, 10),
      score: analysis.ats_analysis.score,
    },
    quick_wins: analysis.quick_wins.slice(0, 5).map((qw) => ({
      id: qw.id,
      text: truncateText(qw.text, 100),
      priority: qw.priority,
    })),
  };

  const json = JSON.stringify(minimalAnalysis);
  const encoded = btoa(encodeURIComponent(json));

  return encoded;
}

/**
 * Decode analysis from URL hash
 */
export function decodeAnalysisFromUrl(hash: string): AnalysisResponse | null {
  try {
    const decoded = decodeURIComponent(atob(hash));
    const parsed = JSON.parse(decoded) as AnalysisResponse;
    return parsed;
  } catch {
    return null;
  }
}

/**
 * Generate shareable URL with encoded analysis
 */
export function generateShareUrl(analysis: AnalysisResponse): string {
  const encoded = encodeAnalysisForUrl(analysis);
  const baseUrl = typeof window !== "undefined" ? window.location.origin : "";
  return `${baseUrl}/results#${encoded}`;
}

/**
 * Copy URL to clipboard
 */
export async function copyShareUrl(analysis: AnalysisResponse): Promise<boolean> {
  const url = generateShareUrl(analysis);

  try {
    await navigator.clipboard.writeText(url);
    return true;
  } catch {
    // Fallback for older browsers
    const textArea = document.createElement("textarea");
    textArea.value = url;
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand("copy");
    document.body.removeChild(textArea);
    return true;
  }
}

/**
 * Truncate text to specified length with ellipsis
 */
function truncateText(text: string, maxLength: number): string {
  if (!text || text.length <= maxLength) return text;
  return text.slice(0, maxLength - 3) + "...";
}
